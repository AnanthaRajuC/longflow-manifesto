{
  "name": "Longflow manifesto",
  "tagline": "The SCRUM Masters have been terminated.",
  "body": "<div align=\"center\">\r\n    <h1>The Longflow Manifesto</h1>\r\n    <em>Version 1</em>\r\n</div>\r\n\r\n## About this manifesto\r\n\r\nThe longflow model is an engineering-centric workflow for serious software developers, tired of the \"Agile\"/\"Scrum\" bullshit.\r\n\r\n## The question of Time\r\n\r\n### Time and Work\r\n\r\nIn the software industry, like in every industry, a business owner does not sell time. A business owner sells a product.\r\nHowever, a software developer does sell his time.\r\n\r\nSomewhere, time must be transformed into improvements to the product.\r\nThe action of applying this transformation to time is called work.\r\n\r\nHowever, the relation between time spent and work done is absolutely *not* linear.\r\nPremature optimization, for example, is a good candidate for a log-like relation, where more and more time is being invested for less and less benefits.\r\nOn the other hand, good refactoring can use a moderate amount of time for exponential returns over a long period of time.\r\n\r\nThis is the key principle of the longflow methodology : **everything has to be done with long-term goals in mind**.\r\n\r\nThat does not mean no prototyping.  \r\nThat does not mean premature optimization.  \r\nThat does mean quality has a price : time.\r\n\r\n### Estimates\r\n\r\nEstimates are to be avoided at all cost.\r\nThey create needless pressure, competition, and participate in a toxic witch-hunt of who is the less productive.\r\n\r\nIn the software development world, it is impossible to produce meaningful estimates, let alone precise ones, for anything but nano-tasks.\r\n\r\nIt is often impossible to split a task into meaningful smaller ones, even more so *before* starting the original task.\r\nJust like it may be impossible to split a function into meaningful smaller ones, when such function is already coherent and provides a self-contained service.\r\n\r\nHave the workflow match the project, not the other way around.  \r\nThis draws a nice parallel with data-oriented design, where the data is the core and the logic have to match it.  \r\n\r\n### Time based events\r\n\r\nFrequent, time-based interactions between executives and engineers are one of the best way to crash a company.  \r\nHaving a meeting once in a week/month or other indicator based soley on time is meaningless. It conveys the idea that all the tasks are the same, that all progress must be at a steady pace.\r\nIt's also an excellent way to focus more on immediate results than on the long term goals.\r\n\r\nInteractions between executives and engineers must be limited in terms of number and frequency.  \r\nIt's also best to be as unintrusive as possible : a mail may be better than a meeting in a lot of cases.\r\n\r\nMicro-management should be avoided at all costs, because it creates interferences between executives and engineers, and reduces creativity.\r\n\r\n*Rushes, sprints, crunch-time, etc. are toxic and dangerous.*\r\n\r\nQuality is infinitely superior to quantity. Software engineers aim to produce working, beautiful, readable code.  \r\nBy forcing deadline upon them, they are encouraged to produce \"the least dysfunctional\" code instead of \"the best possible\" code.\r\nThe longflow methodology advocates having medium to large sized meaningful tasks, self-assigned whenever possible, where developers can leverage both technical and problem-solving skills.\r\nHave developers write no code at first, but simply think about how they can solve the problem. Or, better yet, asking themselves questions like:\r\n\r\n * Is there a problem to solve?\r\n * Can I improve this part of the code?\r\n * Are there tasks I wish I had done differently?\r\n\r\nCuriosity and creativity are very important skills for software developers, but these skills can't develop if there is pressure to release code as fast as possible.\r\nIt is very detrimental to have long, let alone permanent, deadlines.\r\n\r\nDevelopers should be allowed, and even encouraged, to spend some time learning and toying with new things and concepts.\r\nBeing able to apply a large variety of solutions and concepts on a problem is crucial for a good software developer.\r\nDenying their right to learn will hinder the ability of developers to improve and produce quality code.\r\n\r\n## The longflow methodology in simple steps\r\n\r\n### Management\r\n\r\n * Keep thinking about long term goals.\r\n * Let engineers self-assign tasks.\r\n * Value quality over deadlines.\r\n * Let the engineers do engineering.\r\n * Don't micro-manage.\r\n * Don't interfere with engineers more than strictly required.\r\n * Never rush, always think and plan ahead.\r\n * Don't fear to fail.\r\n * Avoid cargo-cults like the plague.\r\n\r\n### Technical\r\n\r\n * Keep thinking about long term goals.\r\n * Pick up your own tasks.\r\n * Try to fix bugs before introducing new features, to an extent.\r\n * Try to clean the codebase before introducing new features, to an extent.\r\n * Try to write the best possible code.\r\n * Don't fear trying something different.\r\n * Think more, write less.\r\n * Always try to learn things, be curious.\r\n * Don't fear running late.\r\n * Don't fear to fail.\r\n * Avoid cargo-cults like the plague.\r\n\r\n## A typical implementation\r\n\r\nA typical implementation of the longflow manifesto, from the point of view of an engineer, is something like this:\r\n\r\n 1. I pick or create a task.  \r\n 2. I spent a few minutes/hours/days thinking about the task. Do we need it? Have I done something similar before? What does the task achieves?  \r\n 3. If the task turns out to be unneeded, go back to 1.  \r\n 4. If I need to learn something to do the task, I go learn it.  \r\n 5. If I *want* to learn something new, I go learn it too.  \r\n 6. I think about the task again. I may go back to 4 or 1 if the things I learned changed my mind about the task.  \r\n 7. I work on the task. I may go back to 2 at any point.  \r\n 8. I finish the task.  \r\n 9. I think about the task again. I may want to go back at 2.  \r\n 10. The task is now considered done, but I (or someone else) can decide to work on it at any time, going back to 2.  \r\n\r\nIt may seems messy at first, but a workflow like this is both extremely flexible and extremely good in terms of quality of the code produced, because everyone can improve any part of the codebase whenever they want.\r\n\r\n## Author\r\n\r\nThis manifesto was written by [Nax](https://github.com/Nax).  \r\nFeel free to modify it.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}